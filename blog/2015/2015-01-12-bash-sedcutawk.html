---
layout: post
title: 'підказка: скрипти bash без sed/cut/awk'
date: '2015-01-12T18:52:00.003+02:00'
author: tivasyk
tags:
- комп'ютери
- linux
- підказки
- bash
modified_time: '2016-03-24T10:30:31.995+02:00'
blogger_id: tag:blogger.com,1999:blog-1498862426470895405.post-6206113621202663680
blogger_orig_url: http://www.tivasyk.info/2015/01/bash-sedcutawk.html
---

в розділі tips, tricks and scripts англомовного <a href="http://crunchbang.org/forums/index.php" target="_blank">форуму crunchbang</a> знайшов цю <a href="http://crunchbang.org/forums/viewtopic.php?pid=413477#p413477" target="_blank">підказку за авторством imbecil</a>: як уникнути використання (чудових!) утиліт <a href="http://www.tivasyk.info/search/?q=sed" target="_blank">sed</a>, cut і awk для нескладної обробки текстових рядків у bash-скриптах. стаття досить детально викладена, з прикладами — тож вирішив перекласти повністю і зберегти тут собі на згадку.<br /><br />може ще комусь стане в пригоді? тоді не полінуйтеся, будь ласка, <a href="http://crunchbang.org/forums/register.php" target="_blank">зареєструватися на форумі</a> й <a href="http://crunchbang.org/forums/viewtopic.php?pid=413477#p413477" target="_blank">подякувати авторові</a> =)<br /><br />1. вступ<br />2. приклади<br />&nbsp;&nbsp;2.1. спосіб «sed+cut»<br />&nbsp;&nbsp;2.2. спосіб «лише bash»<br />3. швидкодія <br />&nbsp;&nbsp;3.1. тестовий скрипт<br />&nbsp;&nbsp;3.2. результати тестування швидкодії<br />4. заключне слово<br /><br /><h3>1. вступ</h3><h4>що?</h4>чимало скриптів bash часто потребують інформації з текстових змінних (або з виводу команд), приміром:<br /><code><br />variable="&nbsp;&nbsp; якийсь текст XXXX-YYYY-ZZ  0xab2345 траляля"<br />#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         ^^^ зауважте пробіли на початку текстового рядка</code><br /><br />потребуючи й сам такого і шукаючи рецептів у тенетах, я помітив, що більшість пропонованих рішень використовують утиліти sed, cut та/або awk в різних комбінаціях. найчастіше текстовий рядок спрощують за допомогою sed, і згодом «вирізають» потрібну частину рядка за допомогою cut чи awk.<br /><br /><h4>чому?</h4>будучи впертим (уникаю використання python/ruby/perl) пуристом (навіщо викликати сторонні утиліти на кшалт sed у випадках, коли bash і сам достатньо потужний), я натрапив на згадку про <a href="http://www.tldp.org/LDP/abs/html/string-manipulation.html" target="_blank">«дивовижну кількість команд для операцій з текстовими рядками»</a> та <a href="http://www.tldp.org/LDP/abs/html/arrays.html" target="_blank">«масиви»</a>, інтегровані у bash, і відкрив для себе, що чимало операцій можна запрограмувати за допомогою цих команд замість вдаватися до запуску sed, cut і awk. а оскільки більшість пошукових запитів у google приводять саме на рецепти з sed/cut/awk, мені видалося непоганою ідеєю порекламувати інтегровані команди bash за допомогою кількох прикладів.<br /><br /><h4>як?</h4>робиться це навдивовижу просто, і, на мою гадку, семантично елегантніше в порівнянні до рецептів з sed, cut і awk. є певні недоліки, зокрема деякі однорядні команди (one-liners) неможливо зконструювати в силу особливостей роботи команд bash. для обробки тексту і масивів, проте загальне враження таке, що використання інтегрованих команд bash робить скрипти більш зрозумілими для читання.<br /><br />далі йтимуть декілька прикладів…<br /><br /><h3>2. приклади</h3>гаразд, ось дуже простий приклад. я хочу витягти кожне чотирицифрове число в окрему змінну рядка на кшалт такого:<br /><code><br />1680x1050+2880+23</code><br /><br />звісно, неважко впізнати звичний рядок з «геометрією» дисплея, такі видає команда xrandr.<br /><br /><h4>2.1 спосіб «sed+cut»</h4>ось простий скрипт, щоби зробити це за допомогою sed:<br /><code><br /># приклад SED<br /># задаймо текстовий рядок<br />xrandroutput="1680x1050+2880+23"<br /><br /># визначмо символ табуляції TAB ('\t')<br /># знадобиться для sed та cut<br />TAB=$(echo -e "\t")<br /><br /># замінімо «x» на тауляцію '\t'<br />array=`echo "$xrandroutput" | sed "s/x/$TAB/"`<br /><br /># замінімо «+» на табуляцію '\t'<br />array=`echo -e "$array" | sed "s/+/$TAB/g"`<br /><br /># збережімо потрібні значення<br />H=`echo -e "$array" | cut -f 1`<br />W=`echo -e "$array" | cut -f 2`<br />X=`echo -e "$array" | cut -f 3`<br />Y=`echo -e "$array" | cut -f 4`</code><br /><br />гакери скрикнуть: «навіщо sed двічі?!» — і матимуть рацію, скрипт можна трошки скоротити:<br /><br /><code><br /># приклад SED<br /># задаймо текстовий рядок<br />xrandroutput="1680x1050+2880+23"<br /><br /># визначмо символ табуляції TAB ('\t')<br /># знадобиться для sed та cut<br />TAB=$(echo -e "\t")<br /><br /># замінімо «x» і «+» на тауляцію '\t'<br />array=`echo "$xrandroutput" | sed "s/[x+]/$TAB/g"`<br /><br /># збережімо потрібні значення<br />H=`echo -e "$array" | cut -f 1`<br />W=`echo -e "$array" | cut -f 2`<br />X=`echo -e "$array" | cut -f 3`<br />Y=`echo -e "$array" | cut -f 4`</code><br /><br />десь так… принаймні такі приклади я стрічав зазвичай. мабуть, це можна ще трохи оптимізувати, але суть не зміниться.<br /><br /><h4>2.2 спосіб «лише bash»</h4>а тепер обіцяний приклад використання лише інтегрованих команд bash:<br /><code><br /># приклад ARRAY<br /># задаймо текстовий рядок <br />xrandroutput="1680x1050+2880+23"<br /><br /># замінімо всі «x» на пробіли « », скориставшись<br /># потужною інтегрованою в bash командою заміни<br /># тексту за шаблоном:<br /># ${string//substring/replacement},<br /># і збережімо результат до змінної «array» <br /># (поки що це не масив)<br />array=${xrandroutput//x/" "}      # результат: "1680 1050+2880+23"<br /><br /># замінімо всі «+» на пробіли « » і збережімо<br /># результат тепер як масив у змінній «array»,<br /># використавши дужки «(» і «)»<br /># заувага: дужки приймають пробіл як роздільник<br /># і таким чином створюють масив значень<br />array=( ${array//+/" "} )     # результат: ( "1680" "1050" "2880" "23" )<br /><br /># надрукуймо результат<br />echo "array[0] = ${array[0]}"<br />echo "array[1] = ${array[1]}"<br />echo "array[2] = ${array[2]}"<br />echo "array[3] = ${array[3]}"</code><br /><br />звісно ж дві команди заміни можна об’єднати в одну:<br /><code><br /># приклад ARRAY-SINGLE<br />...<br /># замінімо всі «x&gt; і «+» на пробіли « »<br /># і збережімо результат в масив з назвою «array»<br />array=( ${xrandroutput//[x+]/" "} )<br />...</code><br /><br />ну хіба ж не простіше і зрозуміліше? вже мовчу про те, що на виході всі дані маємо в одному масиві, а це досить зручно і не захаращує код назвами змінних.<br /><br />аж зголоднів, поки писав це. мушу щось з’їсти і хильнути пива, перш ніж перейти до тестування швидкодії.<br /><br /><h3>3. швидкодія</h3><h4>3.1 тестовий скрипт</h4>чи справді варто використовувати інтегровані команди bash для обробки рядків і масивів, — а чи може це лише альтернативний спосіб і не більше? можна прогнати кілька тестів і подивитися, скільки за часом виконується кожен варіант. спершу я поясню, як саме я тестував. далі подаю чернетку тестового скрипта. ідея проста: запустити декілька (багато) подібних прикладів і заміряти час виконання.<br /><code><br />#!/bin/bash<br /># використання: test [кількість_ітерацій]<br /><br />iter=10000<br /># перевірмо, чи задано кількість ітерацій в командному рядку<br />if [ -n "$1" ]<br />then    <br />iter="$1"<br />fi<br /><br />TAB=$(echo -e "\t")<br /><br /># проженімо ітерації<br />for i in `seq $iter`<br />do<br />#<br /># робочий код для тестування<br />#<br />done</code><br /><br />цей тестовий скрипт запускається таким чином:<br /><code><br />$ /usr/bin/time -f "\nReal: %E\nUser: %U\nSys: %S" ./test 100000</code><br /><br />всередині циклу «do … done» вміщуємо тестовий код (я прибрав коментарі задля компактності):<br /><code><br /># приклад SED<br />xrandroutput="1680x1050+2880+23"<br />array=`echo "$xrandroutput" | sed "s/x/$TAB/"`<br />array=`echo -e "$array" | sed "s/+/$TAB/g"`<br />H=`echo -e "$array" | cut -f 1`</code><br /><br />а потім другий варіант:<br /><code><br /># приклад ARRAY<br />xrandroutput="1680x1050+2880+23"<br />array=${xrandroutput//x/" "}      # "1680 1050+2880+23"<br />array=( ${array//+/" "} )     # ( "1680" "1050" "2880" "23" )</code><br /><br />зауважте, що у варіанті «приклад SED» ми змушені зберігати результат до змінної «H», тоді як у варіанті «приклад ARRAY» всі чотири значення зберігаються в одному масиві з доступом через «array[i]».<br /><br /><h4>3.2 результати тестування швидкодії</h4>щоби отримати надійний результат, я прогнав кожен тест кілька разів (міг би зробити це більш системно, підбивши якусь статистику, проте різниця настільки разюча, що в цім не було необхідности). далі я спробвав підібрати кількість ітерацій так, щоби скрипт виконувався приблизно 10 секунд, і таким чином нормалізувати результати.<br /><br />а результати такі:<br /><code><br />приклад SED:   1000 ітерацій = 2,17 секунд<br />приклад ARRAY: 1000 ітерацій = 0,011 секунд</code><br /><br />так, різниця 200-кратна на користь варіанту «приклад ARRAY». отже, інтегровані команди bash працюють значно швидше, ніж виклик sed.<br /><br />дивно? ну, я очікував дещо вищої продуктивності, але ж не 200-кратно… насправді, тут я запрошую знавців написати оптимальніший код з використанням sed. можливо, це можна зробити краще, ніж вийшло у мене.<br /><br /><h3>4. заключне слово</h3>отже, чи варто користуватися інтегрованими командами bash? спробую підсумувати:<br /><br /><b>переваги</b> (аргументи на користь внутрішніх команд bash: <br />+ це значно швидше;<br />+ код зрозуміліший (на мою думку), з меншою кількістю змінних;<br />+ мені здається, що це простіше програмувати.<br /><br /><b>недоліки</b> (проти):<br />– значна залежність від bash;<br />– хоча масиви і команди обробки рядків мають бути доступні в сучасних версіях bash (вище третьої), все-таки можуть виникати проблеми сумісності в старших версіях;<br />– неможливо реалізувати деякі однорядкові команди (one-liners), які досить просто отримати перенаправленням виводу.<br /><br />наостанок кілька слів:<br /><br />а) сподіваюся, комусь це стане в нагоді. розумію, що хтось скаже: «о, я це й так знав», інші запитають «про що це він взагалі говорить?», проте я таки сподіваюся, що хтось навчиться чогось нового; <br />б) перепрошую, що не спромігся пояснити коротше; також перепрошую за кострубату англійську;<br />в) не соромтеся збиткуватися з мене, якщо я десь тут припустився помилки.<br /><br />кінець. 