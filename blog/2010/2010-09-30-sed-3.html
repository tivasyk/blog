---
layout: post
title: sed — проста текстова магія (частина 3)
date: '2010-09-30T16:33:00.004+03:00'
author: tivasyk
tags:
- комп'ютери
- linux
- підказки
modified_time: '2011-10-20T14:06:16.987+03:00'
thumbnail: http://1.bp.blogspot.com/_wFmUV6FUCKU/TJisR1FMGYI/AAAAAAAAJCM/LnN9BRs5JuQ/s72-c/terminal_icon.png
blogger_id: tag:blogger.com,1999:blog-1498862426470895405.post-6606539506050135667
blogger_orig_url: http://www.tivasyk.info/2010/09/sed-3.html
---

<div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/_wFmUV6FUCKU/TJisR1FMGYI/AAAAAAAAJCM/LnN9BRs5JuQ/s1600/terminal_icon.png" imageanchor="1" style="clear: right; float: right; margin-bottom: 1em; margin-left: 1em;"><img border="0" height="200" src="http://1.bp.blogspot.com/_wFmUV6FUCKU/TJisR1FMGYI/AAAAAAAAJCM/LnN9BRs5JuQ/s200/terminal_icon.png" width="200" /></a></div>після тижневої перерви <a href="http://www.tivasyk.info/2010/09/sed.html">продовжую вивчати sed</a> за допомогою довідника <a href="http://www.catonmat.net/blog/sed-one-liners-explained-part-one/">«famous sed one-liners explained»</a>. попередня, <a href="http://www.tivasyk.info/2010/09/sed-2.html">друга частина серії</a> була присвячена нумерації рядків:<br /><ul><li><a href="http://www.tivasyk.info/2010/09/sed-2.html#2_1">нумерація рядків</a></li><li><a href="http://www.tivasyk.info/2010/09/sed-2.html#2_2">нумерація з вирівнюванням номеру вправо</a></li><li><a href="http://www.tivasyk.info/2010/09/sed-2.html#2_3">нумерація непустих рядків</a></li><li><a href="http://www.tivasyk.info/2010/09/sed-2.html#2_4">кількість рядків у тексті</a></li></ul>цього разу — про перетворення тексту та автоматичну заміну фрагментів за шаблоном.<br /><br /><a name='more'></a><a href="http://draft.blogger.com/blogger.g?blogID=1498862426470895405" name="3_1"></a><br /><h2>3. перетворення тексту і заміни</h2><br /><h3>3.1.&nbsp;перетворити символи нового рядка з формату dos/windows на unix</h3>задача: перетворити комбінацію символів нового рядка в стилі dos/windows (cr/lf) до стилю unix (lf)<br /><blockquote><code>sed 's/.$//'</code></blockquote>команда покладається на те, що кожен текстовий рядок закінчується послідовністю символів <a href="http://en.wikipedia.org/wiki/Carriage_return">cr</a>/<a href="http://en.wikipedia.org/wiki/Line_feed">lf</a> (не перевіряючи), і що виконується вона в середовищі *nix. прочитавши новий рядок в робочий буфер, <i>sed</i> відкидає кінцевий символ нового рядка (lf). команда шукає останній символ рядка в буфері (<code>/.$/</code>) і видаляє, не замінюючи нічим (<code>//</code>).<br /><br /><b>важливо!</b> жодної перевірки, чи справді текст містить переноси в стилі dos/windows, або пошуку саме такої комбінації в тексті — не виконується. тому спосіб цікавий лише академічно: реальні задачі варто вирішувати інакше…<br /><br />кращий спосіб:<br /><blockquote><code>sed 's/^M$//'</code></blockquote>передумова — середовище *nix. команда шукає символ переводу рядка cr (<code>^M</code>), який є останнім в рядку (<code>/^M$/</code>, і видаляє, не замінюючи нічим (<code>//</code>).<br /><br /><b>важливо!</b> тут <code>^M</code> — не дослівно набрана з клавіатури комбінація дашка і великої літери <i>m</i>, а один символ, який можна ввести з клавіатури в терміналі, набравши спершу <i>ctrl+v</i>, а тоді одразу <i>ctrl+m</i>.<br /><br />найкраща варіація цього способу:<br /><blockquote><code>sed 's/\x0D$//'</code></blockquote>по суті, та сама команда, в якій замість самого символа cr вказано його код (13) в шістнадцятковій нотації (<code>0x0D</code>). щоправда, не всі версії <i>sed</i> цей варіант підтримують — потрібна версія <i>gnu sed</i>, але усі версії лінук саме її й використовують.<br /><br /><a href="http://draft.blogger.com/blogger.g?blogID=1498862426470895405" name="3_2"></a><br /><h3>3.2.&nbsp;перетворити символи нового рядка з формату unix на dos/windows</h3>задача: зворотня до попередньої; перетворити символ нового рядка у стилі unix (lf) наприкінці рядка на комбінацію cr/lf у стилі dos/windows.<br /><blockquote><code>sed "s/$/`echo -e \\\r`/"</code></blockquote>передумова — середовище <i>*nix</i>: використано вставку <code>echo -e \r</code> (кожен з двох останніх символів <a href="http://en.wikipedia.org/wiki/Escape_character">екрановано</a>), котра є командою <a href="http://uk.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D0%BD%D0%B0_%D0%BE%D0%B1%D0%BE%D0%BB%D0%BE%D0%BD%D0%BA%D0%B0_Unix">оболонки (shell)</a> і видає символ cr, який додається в кінець рядка (<code>/$/</code>) в робочому буфері — під час виводу рядка у вихідний потік <i>sed</i> автоматично додасть до нього ще символ <i>lf</i>.<br /><br />інший спосіб:<br /><blockquote><code>sed 's/$/\r/'</code></blockquote>цей спосіб працює в <i>gnu sed</i>, і працює аналогічно — але без необхідності застосовувать команду оболонки: просте <code>\r</code> позначає символ <i>cr</i>.<br /><br /><b>зауваження.</b> тут я свідомо пропускаю всі способи аналогічного перетворення рядків у середовищі <i>dos/windows</i>, бо мені без потреби, а якщо доведеться — завжди можна пошукати <a href="http://www.google.com.ua/search?q=sed+one-liners&amp;ie=utf-8&amp;oe=utf-8&amp;aq=t&amp;rls=org.mozilla:en-US:official&amp;client=firefox-a">sed one-liners</a> у тенетах.<br /><br /><a href="http://draft.blogger.com/blogger.g?blogID=1498862426470895405" name="3_3"></a><br /><h3>3.3.&nbsp;прибрати пробіли і табуляцію на початку рядка</h3>задача: прибрати пробіли і символи табуляції на початку кожного рядка тексту.<br /><blockquote><code>sed 's/^[ \t]*//'</code></blockquote>проста команда: шукає будь-яку кількість (<code>*</code>) пробілів і символів табуляції (<code>[ \t]</code>) на початку рядка (<code>^</code> — і заміняє «нічим» (<code>//</code>), тобто видаляє.<br /><br /><b>приклад:</b><br /><blockquote><code>cat test.txt | sed 's/^[ \t]*//'</code></blockquote>результат:<br /><blockquote><code>Бринь бандура, та й замовкне…<br />Чом же не заграє?<br />Стоїть старець під віконцем, —<br />Чом же не співає?</code></blockquote><br /><a href="http://draft.blogger.com/blogger.g?blogID=1498862426470895405" name="3_4"></a><br /><h3>3.4.&nbsp;прибрати пробіли в кінці рядка</h3>задача: прибрати зайві пробіли в кінці кожного рядка тексту.<br /><blockquote><code>sed 's/[ \t]*$//'</code></blockquote>аналогічно <a href="http://draft.blogger.com/blogger.g?blogID=1498862426470895405#3_3">попередньому прикладу</a> — але шаблон в команді заміни (<code>s///</code>) відбирає пробіли і табуляцію в кінці (<code>$</code>) рядка.<br /><br /><a href="http://draft.blogger.com/blogger.g?blogID=1498862426470895405" name="3_5"></a><br /><h3>3.5.&nbsp;видалити пробіли на початку і в кінці рядка</h3>задача: об’єднати в одній команді рішення <a href="http://draft.blogger.com/blogger.g?blogID=1498862426470895405#3_3">обох попередніх задач</a>.<br /><blockquote><code>sed 's/^[ \t]*//;s/[ \t]*$//'</code></blockquote>можна було б і просто запустити двічі <i>sed</i>… але красивіший спобів — виконати його один раз, вказавши дві команди через крапку з комою, вони виконуватимуться послідовно над вмістом робочого буфера.<br /><br /><a href="http://draft.blogger.com/blogger.g?blogID=1498862426470895405" name="3_6"></a><br /><h3>3.6.&nbsp;відступ зліва</h3>задача: утворити відступ зліва для всього тексту, додавши до кожного рядка по 5 пробілів на початку.<br /><blockquote><code>sed 's/^/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/'</code></blockquote>проста команда заміни: пошук початку рядка в робочому буфері (<code>/^/</code>) і вставка в цій позиції потрібної кількості пробілів (<code>/     /</code>).<br /><br /><a href="http://draft.blogger.com/blogger.g?blogID=1498862426470895405" name="3_7"></a><br /><h3>3.7.&nbsp;виключка тексту вправо</h3>задача: виключити текст вправо, вирівнявши кожен рядок до 79-ї позиції.<br /><blockquote><code>sed -e :a -e 's/^.\{1,78\}$/ &amp;/;ta'</code></blockquote>значно складніший приклад. рішення використовує нову опцію (<code>-e</code>) і дві команди (<code>:</code> та <code>t</code>). опція <code>-e</code> подібно до <code>;</code> дозволяє поєднувати кілька послідовних команд <i>sed</i> в одному рядку (і процесі):<br /><blockquote><code>sed -e &lt;команда 1&gt; -e &lt;команда 2&gt;</code></blockquote>команда <code>:</code> створює мітку, а <code>t</code> реалізує логіку умовного розгалуження, як у мовах програмування: якщо попередня команда змінила текст в робочому буфері, <code>t</code> повертає sed до виконання до першої команди після вказаної мітки, якщо з змін не було — перехід не відбувається.<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/_wFmUV6FUCKU/TKRF6Uz5uSI/AAAAAAAAJDY/ZYMUfSOU6DE/s1600/sed_01.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="137" src="http://2.bp.blogspot.com/_wFmUV6FUCKU/TKRF6Uz5uSI/AAAAAAAAJDY/ZYMUfSOU6DE/s320/sed_01.png" width="320" /></a></div>отже, логіка команди така: фрагмент <code>-e :a</code> створює мітку з ім’ям <i>a</i>; команда <i>s</i> вибирає в робочому буфері фрагмент тексту, який містить не більше 78 будь-яких символів (<code>.{1,78}</code>) від початку (<code>^</code>) до кінця (<code>$</code>), і заміняє його увесь на цей же фрагмент (&amp;), але з пробілом попереду (<code>/ &amp;/</code>) — таким чином текст в буфері стає довшим на один передній пробіл. наступна команда <code>ta</code> переходить назад до мітки <code>a</code>… і так відбувається доти, поки довжина тексту в буфері є не більшою заданої в шаблоні (78 символів) — але як тільки вона стає 79, перехід на мітку a більше не виконується, <i>sed</i> завершує виконання послідовності — і виводить результат у вихідний потік.<br /><br /><b>важливо!</b> для правильної роботи цієї команди її варто об’єднати <a href="http://draft.blogger.com/blogger.g?blogID=1498862426470895405#3_5">з видаленням табуляції на початку рядка та кінцевих пробілів</a>:<br /><blockquote><code>sed -e 's/^[ \t]*//;s/[ \t]*$//' -e :a -e 's/^.\{1,78\}$/ &amp;/;ta'</code></blockquote><br /><a href="http://draft.blogger.com/blogger.g?blogID=1498862426470895405" name="3_8"></a><br /><h3>3.8.&nbsp;виключка тексту по центру</h3>задача: відцентрувати кожен рядок тексту в рамках простору шириною 79 символів.<br /><blockquote><code>sed  -e :a -e 's/^.\{1,77\}$/ &amp; /;ta'</code></blockquote>все аналогічно до <a href="http://draft.blogger.com/blogger.g?blogID=1498862426470895405#3_7">попередньому прикладу</a>, за винятком того, що центрувати можна лише ті рядки, котрі хоча б на 2 символи коротші за максимальну ширину (79), а доповнювати пробілами — з обох сторін (<code>/ &amp; /</code>). і теж варто спершу видаляти передні та кінцеві пробіли й табуляцію.<br /><br /><b>важливо!</b> недолік цього рішення в тім, що — сюрприз! — він генерує кінцеві пробіли. а вони ж насправді зайві. звісно, можна результат роботи команди пропустити ще раз через знайоме <a href="http://draft.blogger.com/blogger.g?blogID=1498862426470895405#3_4">видалення кінцевих пробілів</a>, але є елегантніший варіант:<br /><blockquote><code>sed  -e :a -e 's/^.\{1,77\}$/ &amp;/;ta' -e 's/\( *\)\1/\1/'</code></blockquote>перша частина зрозуміла — це <a href="http://draft.blogger.com/blogger.g?blogID=1498862426470895405#3_7">виключка вправо</a>, а от друга цікава, бо використовує <a href="http://www.tivasyk.info/2010/09/sed-2.html#2_2">тимчасову змінну</a>, але як красиво використовує! шаблон <code>( *)\1</code> (прибрав екрануючі зворотні риски) означає: знайти в тексті першу найбільшу доступну послідовність пробілів (запам’ятавши її в змінній <code>\1</code>), але так, щоби за нею слідувала… така ж точно (оте <code>\1</code>) послідовність! і вибрати для наступної операції обидві. <br /><br />що це значить? якщо в тексті є послідовність із п’яти пробілів поспіль — цей шаблон знайде перші два (за ними ж ідуть ще два!), збереже їх в змінну <code>\1</code> — і вибере для редагування два+два пробіли, залишивши п’ятий (зайвий) поза увагою.<br /><br />останній фрагмент цієї команди (<code>/\1/</code>) — заміна вибраного фрагменту (х+х пробілів) збереженою в <code>\1</code> половинкою (х пробілів). по суті текстовий рядок спершу виключено вправо, а тоді з передніх пробілів видалено меншу половину.<br /><br /><a href="http://draft.blogger.com/blogger.g?blogID=1498862426470895405" name="3_9"></a><br /><h3>заміна фрагмента тексту</h3>задача: замінити довільний (наприклад, перший або другий) фрагмент в тексті згідно шаблону іншим фрагментом.<br /><blockquote><code>sed 's/foo/bar/x'</code></blockquote>тут <i>foo</i> — фрагмент, який треба знайти, <i>bar</i> — текст для заміни, а x — номер фрагменту (1 або 2 в цьому прикладі). якщо параметр x опустити — матиметься на увазі перший, а якщо вказати <code>g</code> (від <i>global</i>) — буде замінено всі знайдені за шаблоном фрагменти.<br /><br /><b>важливо!</b> лік фрагментів ведеться не в тексті загалом, а в кожному рядку окремо!<br /><br /><b>приклад</b> (використано <a href="http://www.tivasyk.info/2010/09/sed.html#0_2">раніше створений тестовий файл</a>):<br /><blockquote><code>cat ~/test.txt | sed 's/а/А/'</code></blockquote>результат:<br /><blockquote><code>Бринь бАндура, та й замовкне…<br />&nbsp;&nbsp;&nbsp;Чом же не зАграє?<br />Стоїть стАрець під віконцем, —<br />&nbsp;&nbsp;&nbsp;Чом же не співАє?</code></blockquote>інший <b>приклад:</b><br /><blockquote><code>cat ~/test.txt | sed 's/а/А/2'</code></blockquote>…і результат:<br /><blockquote><code>Бринь бандурА, та й замовкне…<br />&nbsp;&nbsp;&nbsp;Чом же не загрАє?<br />Стоїть старець під віконцем, —<br />&nbsp;&nbsp;&nbsp;Чом же не співає?</code></blockquote>ще один <b>приклад:</b><br /><blockquote><code>cat ~/test.txt | sed 's/а/А/g'</code></blockquote>…і результат:<br /><blockquote><code>Бринь бАндурА, тА й зАмовкне…<br />&nbsp;&nbsp;&nbsp;Чом же не зАгрАє?<br />Стоїть стАрець під віконцем, —<br />&nbsp;&nbsp;&nbsp;Чом же не співАє?</code></blockquote>для одного допису досить. далі буде!<br /><br /><b>оновлення.</b> аж через рік я взявся пригадувати просту текстову магію <a href="http://www.tivasyk.info/2011/10/sed-sedgy-seductrice.html">для цілком практичної задачки</a>.