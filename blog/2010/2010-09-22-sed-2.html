---
layout: post
title: sed — проста текстова магія (частина 2)
date: '2010-09-22T18:20:00.002+03:00'
author: tivasyk
tags:
- комп'ютери
- linux
- підказки
modified_time: '2011-10-20T11:13:57.282+03:00'
blogger_id: tag:blogger.com,1999:blog-1498862426470895405.post-4414121144180571604
blogger_orig_url: http://www.tivasyk.info/2010/09/sed-2.html
---

продовжую вивчати <b>потоковий неінтерактивний текстовий редактор sed</b>. <a href="http://www.tivasyk.info/2010/09/sed.html">попередній допис</a> містив приклади використання для додавання в текст інтервалів між рядками та вибіркового видалення рядків. найцікавіші приклади були такі:<br /><ul><li><a href="http://www.tivasyk.info/2010/09/sed.html#1_1">«розумне» додавання подвійного інтервалу між рядками</a></li><li><a href="http://www.tivasyk.info/2010/09/sed.html#1_4">вилучення пустих рядків</a></li><li><a href="http://www.tivasyk.info/2010/09/sed.html#1_8">додавання пустих рядків над і під вибраним текстом</a></li><li><a href="http://www.tivasyk.info/2010/09/sed.html#1_9">вилучення парних або непарних рядків</a></li></ul>ходімо далі.<br /><br /><a name='more'></a><a href="http://www.blogger.com/post-edit.g?blogID=1498862426470895405&amp;postID=4414121144180571604" name="2_1"></a><br /><h2>2. нумерація рядків</h2><br /><h3>2.1. проста нумерація рядків</h3>задача: пронумерувати кожен рядок вхідного файлу.<br /><blockquote><code>sed = | sed 'N;s/\n/\t/'</code></blockquote>ага, починаються значно складніші приклади. тут маємо насправді дві різних команди. перший sed застосовує команду =, котра просто виводить у вихідний потік номер поточного рядка, а тоді — новим рядком — виводить текст з робочого буфера. побачити, як це працює, можна на простому прикладі:<br /><blockquote><code>cat test.txt | sed =</code></blockquote>результат буде такий:<br /><blockquote><code>1<br />Бринь бандура, та й замовкне…<br />2<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Чом же не заграє?<br />3<br />Стоїть старець під віконцем, —<br />4<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Чом же не співає?</code></blockquote>…і т.д. не зовсім те, що треба — хотілося би об’єднати номер і подальший текст в одному рядку. для цього потрібен другий sed: він завантажує перший рядок виводу («1») в робочий буфер, команда N (від <i>next</i> — наступний) додає до робочого буфера (<i>pattern space</i>) символ переносу рядка (<i>\n</i>), а тоді завантажує і приєднує наступний рядок з вхідного потоку («Бринь бандура, та й замовкне…») — це вже близько, але треба позбутися того зайвого <i>\n</i> посередині… тут працює команда <i>s///</i>, котра шукає в робочому буфері фрагмент тексту за шаблоном і заміняє на вказаний фрагмент — в нашому випадку шукає символ <i>\n</i> (новий рядок) і заміняє на <i>\t</i> (табуляція).<br /><br /><b>приклад</b>:<br /><blockquote><code>cat test.txt | sed = | sed 'N;s/\n/\t/'</code></blockquote>результат: вивід тексту з нумерацією рядків і табульованим відступом зліва.<br /><br /><a href="http://www.blogger.com/post-edit.g?blogID=1498862426470895405&amp;postID=4414121144180571604" name="2_2"></a><br /><h3>2.2.&nbsp;нумерація рядків з вирівнюванням номеру вправо</h3>задача: пронумерувати кожен рядок вхідного тексту, вирівнявши номери по правій стороні.<br /><blockquote><code>sed = | sed 'N; s/^/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/; s/&nbsp;*\(.\{6,\}\)\n/\1&nbsp;&nbsp;/'</code></blockquote><b>важливо!</b> <i>sed</i> дуже чутливий до синтаксису рядка з параметрами… кожен символ важливий. буквально наявність чи відсутність пробілу перед зірочкою <i>*</i> в команді може означати помилку в роботі команди. враховуючи загальну нечитабельність синтаксису команд <i>sed</i> і регулярних виразів — тут є над чим задуматися новачкові.<br /><br />перша частина зрозуміла (<a href="http://www.blogger.com/post-edit.g?blogID=1498862426470895405&amp;postID=4414121144180571604#2_1">див. п. 2.1</a>) — це вставка нумерації перед кожним текстовим рядком. далі: команда N з’єднує два рядки (номер і наступний текстови й рядок) в один, з переносом рядка (<code>\n</code>) десь посередині. команда <code>s/^/&lt;тут_5_пробілів&gt;/</code> — це вже знайома команда пошуку і заміни (<a href="http://www.blogger.com/post-edit.g?blogID=1498862426470895405&amp;postID=4414121144180571604#2_1">див. п. 2.1</a>), котра вставляє необхідну кількість пробілів на початку кожного рядка (регулярний вираз <code>^ </code>означає якраз початок рядка).<br /><br />отже, якщо взяти для прикладу перший рядок тестового файлу, на цьому етапі в робочому буфері <i>sed</i> матиме таке (пробіли заміняю мінусами - для наглядности): <br /><blockquote><code>-----1\nБринь бандура, та й замовкне…</code></blockquote>наступна команда <code>s</code> містить складний регулярний вираз, якщо прибрати <a href="http://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%80%D0%B0%D1%82%D0%BD%D0%B0%D1%8F_%D0%BA%D0%BE%D1%81%D0%B0%D1%8F_%D1%87%D0%B5%D1%80%D1%82%D0%B0">зворотні похилі риски</a>, що позначають <a href="http://ru.wikipedia.org/wiki/%D0%AD%D0%BA%D1%80%D0%B0%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D1%81%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB%D0%BE%D0%B2">екранування спеціальних символів</a>, маємо <a href="http://en.wikipedia.org/wiki/Regexp">такий шаблон</a>: <code>-*(.{6,})\n</code> (пробіл замінено на мінус). він означає, що треба знайти у робочому буфері нуль або більше символів <code>-</code>, за котрим йтиме фрагмент з 6 будь-яких символів (<code>.{6,}</code>), за котрим у свою чергу йтиме символ нового рядка <code>\n</code>.<br /><br /><b>важливо!</b> дужки змушують sed запам’ятати в першій тимчасовій змінній все, що відповідає частині регулярного виразу в дужках — тобто в моєму прикладі шість символів зі знайденого фрагменту, без зайвих <code>-</code> і без <code>\n</code>.<br /><br />отже, на прикладі першого рядка з тестового файлу, буде знайдено фрагмент:<br /><blockquote><code>-----1\n</code></blockquote>а в першій тимчасовій змінній опиниться такий фрагмент:<br /><blockquote><code>-----1</code></blockquote>остання частина цієї команди (тобто <code>/\1&nbsp;&nbsp;/</code>) заміняє знайдений фрагмент вмістом першої тимчасової змінної (<code>\1</code>) плюс два пробіли (для відступу до тексту). очевидно, що «зайвого» символу <code>\n</code> ми позбулися — а якби номер складався не з однієї цифри 1, а з двох, трьох чи п’яти (наприклад <code>-----123</code>), то і «зайві» мінуси зліва також було би видалено і залишено лише шість символів з номером включно (<code>---123</code>)!<br /><br />поекспериментувавши з наглядними мінусами замість пробілів у команді, їх треба знову замінити на пробіли — і готово, задачу виконано.<br /><br /><b>приклад:</b><br /><blockquote><code>cat test.txt | sed = | sed 'N; s/^/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/; s/&nbsp;*\(.\{6,\}\)\n/\1&nbsp;&nbsp;/'</code></blockquote>результат:<br /><blockquote><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;Бринь бандура, та й замовкне…<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Чом же не заграє?<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;Стоїть старець під віконцем, —<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Чом же не співає?</code></blockquote><br /><a href="http://draft.blogger.com/blogger.g?blogID=1498862426470895405" name="2_3"></a><br /><h3>2.3.&nbsp;нумерація лише непустих рядків</h3>задача: пронумерувати лише непусті рядки в тексті.<br /><blockquote><code>sed '/./=' | sed '/./N; s/\n/&nbsp;&nbsp;/'</code></blockquote>перший <i>sed</i> відбирає лише ті рядки, в яких є бодай один символ (<code>/./</code>) — і додає перед ними поточний номер рядка (<a href="http://www.blogger.com/post-edit.g?blogID=1498862426470895405&amp;postID=4414121144180571604#2_1">див. п. 2.1</a>), пусті рядки виводяться без змін. другий <i>sed</i> знову вибирає непустий рядок, з номером (<code>/./</code>), поєднує його з наступним текстовим (<code>N</code>), пропускаючи пусті рядки без змін; наступна команда заміни <code>s</code> позбувається символа <code>\n</code> всередині кожного рядка, заміняючи його на пару пробілів для відступу.<br /><br /><b>приклад:</b><br /><blockquote><code>cat test.txt | sed '/./=' | sed '/./N; s/\n/&nbsp;&nbsp;/'</code></blockquote>результат:<br /><blockquote><code>1&nbsp;&nbsp;Бринь бандура, та й замовкне…<br />2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Чом же не заграє?<br />3&nbsp;&nbsp;Стоїть старець під віконцем, —<br />4&nbsp;&nbsp;&nbsp;&nbsp;Чом же не співає?<br /><br />6&nbsp;&nbsp;Ой ходив би я по селах<br />7&nbsp;&nbsp;&nbsp;&nbsp;Од хати до хати,<br />8&nbsp;&nbsp;Ой співав би на ввесь голос, —<br />9&nbsp;&nbsp;&nbsp;&nbsp;Нікому співати!</code></blockquote><b>важливо!</b> очевидно, що результат дивний — пустий рядок не має номера, але нумерація таки враховує його як п’ятий. це особливості роботи команди <code>=</code>, вона ж бо виводить поточний номер зчитаного рядка, незалежно від того, пустий він чи ні! щоби реалізувати правильну нумерацію, котра справді ігноруватиме пусті рядки — треба подумати. пізніше візьмуся до цього.<br /><br /><a href="http://draft.blogger.com/blogger.g?blogID=1498862426470895405" name="2_4"></a><br /><h3>2.4.&nbsp;підрахувати кількість рядків у тексті</h3>задача: підрахувати кількість рядків у тексті й вивести в термінал.<br /><blockquote><code>sed -n '$='</code></blockquote>опція <code>-n</code> змушує <i>sed</i> не виводити нічого у вихідний потік, якщо вивід не вимагається явно командою (такою, як <code>p</code> чи деякі інші). команда <code>=</code>виводила б номер кожного зчитаного рядка… якби не модифікатор <code>$</code>, котрий застосовує команду лише до останнього рядка у вхідному потоці. тобто у вивід попаде лише номер останнього рядка — і більше нічого.<br /><br /><b>приклад:</b><br /><blockquote><code>cat test.txt | sed -n '$='</code></blockquote>для <a href="http://www.tivasyk.info/2010/09/sed.html#0_2">тестового файлу</a> результат буде такий:<br /><blockquote><code>9</code></blockquote>команда нарахувала 9 рядків — враховано і пустий рядок у файлі, як і в попередньому прикладі (<a href="http://www.blogger.com/post-edit.g?blogID=1498862426470895405&amp;postID=4414121144180571604#2_3">див. п. 2_3</a>).<br /><br />наразі все з нумерацією. <a href="http://www.tivasyk.info/2010/09/sed-3.html">далі ще буде</a>.